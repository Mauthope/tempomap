<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Detec√ß√£o de Pessoas por Zona</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 10px; background: #f9f9f9; }
    #container { position: relative; max-width: 800px; margin: auto; }
    video, canvas {
      width: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }
    #videoWrapper {
      position: relative;
      width: 100%;
      padding-top: 56.25%; /* 16:9 ratio */
    }
    video, canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    #controls {
      margin-bottom: 10px;
      text-align: center;
    }
    #zonasList {
      font-size: 14px;
      margin-top: 10px;
    }
    #urlInput {
      width: 60%;
      padding: 4px;
    }
  </style>
</head>
<body>

<div id="controls">
  <button onclick="loadFromPC()">üìÅ V√≠deo do PC</button>
  <button onclick="loadFromURL()">üåê Link da Web</button>
  <button onclick="loadFromCam()">üì∑ C√¢mera Ao Vivo</button><br><br>
  <input type="file" id="fileInput" accept="video/*" style="display: none;">
  <input type="text" id="urlInput" placeholder="Cole aqui a URL do v√≠deo" />
  <button onclick="setVideoFromURL()">Carregar</button><br><br>
  <button onclick="clearZones()">üßπ Limpar Zonas</button>
</div>

<div id="container">
  <div id="videoWrapper">
    <video id="video" autoplay muted playsinline></video>
    <canvas id="canvas"></canvas>
  </div>
</div>

<div id="zonasList"></div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.9.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
<script>
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const zonas = [];
  const zonasTimers = {};
  let model;

  let startX, startY, isDrawing = false;

  function resizeCanvas() {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
  }

  // Escolha da fonte
  function loadFromPC() {
    document.getElementById('fileInput').click();
  }

  document.getElementById('fileInput').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      video.srcObject = null;
      video.src = URL.createObjectURL(file);
      video.play();
      video.addEventListener('loadedmetadata', resizeCanvas);
    }
  });

  function loadFromURL() {
    document.getElementById('urlInput').focus();
  }

  function setVideoFromURL() {
    const url = document.getElementById('urlInput').value;
    if (url) {
      video.srcObject = null;
      video.src = url;
      video.play();
      video.addEventListener('loadedmetadata', resizeCanvas);
    }
  }

  async function loadFromCam() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      video.srcObject = stream;
      video.play();
      video.addEventListener('loadedmetadata', resizeCanvas);
    } catch (err) {
      alert("Erro ao acessar a c√¢mera: " + err.message);
    }
  }

  // Desenho das zonas
  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    startX = e.clientX - rect.left;
    startY = e.clientY - rect.top;
    isDrawing = true;
  });

  canvas.addEventListener('mouseup', (e) => {
    if (!isDrawing) return;
    const rect = canvas.getBoundingClientRect();
    const endX = e.clientX - rect.left;
    const endY = e.clientY - rect.top;
    const name = prompt("Nome da zona:");
    if (name) {
      const zone = {
        name,
        x: Math.min(startX, endX),
        y: Math.min(startY, endY),
        w: Math.abs(endX - startX),
        h: Math.abs(endY - startY),
        time: 0,
        active: false,
      };
      zonas.push(zone);
      saveZones();
      updateZonasList();
    }
    isDrawing = false;
  });

  function pointInRect(x, y, rect) {
    return x >= rect.x && x <= rect.x + rect.w && y >= rect.y && y <= rect.y + rect.h;
  }

  function updateZonasList() {
    const div = document.getElementById('zonasList');
    div.innerHTML = '<strong>Zonas Monitoradas:</strong><br>' + zonas.map(z =>
      `${z.name}: ${formatTime(z.time)}`
    ).join('<br>');
  }

  function saveZones() {
    localStorage.setItem('zonas', JSON.stringify(zonas));
  }

  function loadZones() {
    const data = localStorage.getItem('zonas');
    if (data) {
      zonas.push(...JSON.parse(data));
      updateZonasList();
    }
  }

  function clearZones() {
    zonas.length = 0;
    localStorage.removeItem('zonas');
    updateZonasList();
  }

  function formatTime(s) {
    const min = Math.floor(s / 60);
    const sec = s % 60;
    return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
  }

  async function detectFrame() {
    if (video.readyState === 4) {
      const predictions = await model.detect(video);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (const zone of zonas) {
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        ctx.strokeRect(zone.x, zone.y, zone.w, zone.h);
        ctx.fillStyle = 'rgba(255,0,0,0.2)';
        ctx.fillRect(zone.x, zone.y, zone.w, zone.h);
        ctx.fillStyle = 'black';
        ctx.fillText(zone.name, zone.x + 4, zone.y + 12);
      }

      const people = predictions.filter(p => p.class === 'person' && p.score > 0.6);

      zonas.forEach(zone => {
        const found = people.some(p => {
          const px = p.bbox[0] + p.bbox[2]/2;
          const py = p.bbox[1] + p.bbox[3]/2;
          return pointInRect(px, py, zone);
        });

        if (found && !zone.active) {
          zone.active = true;
          zonasTimers[zone.name] = setInterval(() => {
            zone.time++;
            updateZonasList();
            saveZones();
          }, 1000);
        } else if (!found && zone.active) {
          clearInterval(zonasTimers[zone.name]);
          zone.active = false;
        }
      });
    }

    requestAnimationFrame(detectFrame);
  }

  async function main() {
    model = await cocoSsd.load();
    loadZones();
    detectFrame();
  }

  main();
</script>
</body>
</html>
